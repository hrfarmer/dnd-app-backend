// make a table to store dnd sessions (needs to be something other than sessions obv)
// the name can be autogenerated but it needs to have a unique id
// messages will be stored in a json file, see if its possible to put a function reference in a mutex on the app state (to theoretically make sure everything goes in order)
use sqlx::{Error, Pool, Postgres};

use crate::{DiscordUser, UserSession};

pub async fn add_user(
    conn: &Pool<Postgres>,
    user: &DiscordUser,
    access_token: &str,
    refresh_token: &str,
) -> Result<UserSession, Error> {
    let user_response = sqlx::query!(
        "INSERT INTO users (username, access_token, refresh_token) VALUES ($1, $2, $3) RETURNING id",
        user.username,access_token,refresh_token
    )
    .fetch_one(conn)
    .await?;

    match sqlx::query!("INSERT INTO session (user_id, discord_id, username, discriminator, global_name, avatar, accent_color) VALUES ($1, $2, $3, $4, $5, $6, $7)", user_response.id, user.id, user.username, user.discriminator, user.global_name.as_ref().unwrap_or(&user.username), user.avatar, user.accent_color).execute(conn).await {
            Ok(_) => {
                return Ok(UserSession{access_token: access_token.to_string(), refresh_token: refresh_token.to_string(), session: user.clone()});
            }
            Err(err) => {
                dbg!(&err);
                return Err(err);
            }
        };
}

pub struct AccessTokens {
    pub access_token: String,
    pub refresh_token: String,
}

pub async fn get_session_token(
    conn: &Pool<Postgres>,
    access_token: &str,
) -> Result<UserSession, Error> {
    let tokens = sqlx::query_as!(
        AccessTokens,
        "SELECT access_token, refresh_token FROM users WHERE access_token = $1",
        access_token
    )
    .fetch_one(conn)
    .await?;

    let session = sqlx::query_as!(
        DiscordUser,
        "
            SELECT discord_id AS id, username, discriminator, global_name, avatar, accent_color FROM session WHERE user_id = (SELECT id FROM users WHERE access_token = $1)
        ",
        access_token
    )
    .fetch_one(conn)
    .await?;

    return Ok(UserSession {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        session,
    });
}

pub async fn get_session_id(conn: &Pool<Postgres>, id: &str) -> Result<UserSession, Error> {
    let session = sqlx::query_as!(
        DiscordUser,
        "
            SELECT discord_id AS id, username, discriminator, global_name, avatar, accent_color FROM session WHERE discord_id = $1
        ",
        id
    )
    .fetch_one(conn)
    .await?;

    let tokens = sqlx::query_as!(
        AccessTokens,
        "SELECT access_token, refresh_token FROM users WHERE EXISTS (SELECT user_id FROM session WHERE discord_id = $1)",
        id
    )
    .fetch_one(conn)
    .await?;

    return Ok(UserSession {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        session,
    });
}

pub async fn refresh_tokens(
    conn: &Pool<Postgres>,
    access_token: &str,
    new_access_token: &str,
    new_refresh_token: &str,
) -> Result<AccessTokens, Error> {
    sqlx::query!(
        "UPDATE users SET access_token = $1, refresh_token = $2 WHERE access_token = $3",
        new_access_token,
        new_refresh_token,
        access_token
    )
    .execute(conn)
    .await?;

    Ok(AccessTokens {
        access_token: new_access_token.to_string(),
        refresh_token: new_refresh_token.to_string(),
    })
}

pub struct UserId {
    id: i32,
}

pub async fn get_user_id(conn: &Pool<Postgres>, access_token: &str) -> Result<UserId, Error> {
    let user = sqlx::query_as!(
        UserId,
        "SELECT id FROM users WHERE access_token = $1",
        access_token
    )
    .fetch_one(conn)
    .await?;

    Ok(user)
}

#[derive(serde::Serialize)]
pub struct DndSession {
    id: i32,
    creator_id: i32,
    name: String,
    created_at: Option<chrono::NaiveDateTime>,
    last_updated: Option<chrono::NaiveDateTime>,
}

pub async fn create_dnd_session(
    conn: &Pool<Postgres>,
    access_token: &str,
    name: &str,
) -> Result<DndSession, Error> {
    let user_id = get_user_id(conn, access_token).await?;

    let res = sqlx::query_as!(
        DndSession,
        "INSERT INTO dnd_session (creator_id, name) VALUES ($1, $2) RETURNING *",
        user_id.id,
        name
    )
    .fetch_one(conn)
    .await?;

    Ok(res)
}

pub async fn get_dnd_sessions(
    conn: &Pool<Postgres>,
    access_token: &str,
) -> Result<Vec<DndSession>, Error> {
    let user_id = get_user_id(conn, access_token).await?;
    let res = sqlx::query_as!(
        DndSession,
        "SELECT * FROM dnd_session WHERE creator_id = $1",
        user_id.id
    )
    .fetch_all(conn)
    .await?;

    Ok(res)
}
