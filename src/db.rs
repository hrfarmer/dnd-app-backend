use rand::{distributions::Alphanumeric, Rng};
use serde::Serialize;
// make a table to store dnd sessions (needs to be something other than sessions obv)
// the name can be autogenerated but it needs to have a unique id
// messages will be stored in a json file, see if its possible to put a function reference in a mutex on the app state (to theoretically make sure everything goes in order)
use sqlx::{Error, Pool, Postgres};

use crate::{DiscordUser, UserSession};

pub async fn add_user(
    conn: &Pool<Postgres>,
    user: &DiscordUser,
    access_token: &str,
    refresh_token: &str,
) -> Result<UserSession, Error> {
    let user_response = sqlx::query!(
        "INSERT INTO users (username, access_token, refresh_token) VALUES ($1, $2, $3) RETURNING id",
        user.username,access_token,refresh_token
    )
    .fetch_one(conn)
    .await?;

    match sqlx::query!("INSERT INTO session (user_id, discord_id, username, discriminator, global_name, avatar, accent_color) VALUES ($1, $2, $3, $4, $5, $6, $7)", user_response.id, user.id, user.username, user.discriminator, user.global_name.as_ref().unwrap_or(&user.username), user.avatar, user.accent_color).execute(conn).await {
            Ok(_) => {
                return Ok(UserSession{access_token: access_token.to_string(), refresh_token: refresh_token.to_string(), session: user.clone()});
            }
            Err(err) => {
                dbg!(&err);
                return Err(err);
            }
        };
}

pub struct AccessTokens {
    pub access_token: String,
    pub refresh_token: String,
}

pub async fn get_session_token(
    conn: &Pool<Postgres>,
    access_token: &str,
) -> Result<UserSession, Error> {
    let tokens = sqlx::query_as!(
        AccessTokens,
        "SELECT access_token, refresh_token FROM users WHERE access_token = $1",
        access_token
    )
    .fetch_one(conn)
    .await?;

    let session = sqlx::query_as!(
        DiscordUser,
        "
            SELECT discord_id AS id, username, discriminator, global_name, avatar, accent_color FROM session WHERE user_id = (SELECT id FROM users WHERE access_token = $1)
        ",
        access_token
    )
    .fetch_one(conn)
    .await?;

    return Ok(UserSession {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        session,
    });
}

pub async fn get_session_id(conn: &Pool<Postgres>, id: &str) -> Result<UserSession, Error> {
    let session = sqlx::query_as!(
        DiscordUser,
        "
            SELECT discord_id AS id, username, discriminator, global_name, avatar, accent_color FROM session WHERE discord_id = $1
        ",
        id
    )
    .fetch_one(conn)
    .await?;

    let tokens = sqlx::query_as!(
        AccessTokens,
        "SELECT access_token, refresh_token FROM users WHERE EXISTS (SELECT user_id FROM session WHERE discord_id = $1)",
        id
    )
    .fetch_one(conn)
    .await?;

    return Ok(UserSession {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        session,
    });
}

pub async fn refresh_tokens(
    conn: &Pool<Postgres>,
    access_token: &str,
    new_access_token: &str,
    new_refresh_token: &str,
) -> Result<AccessTokens, Error> {
    sqlx::query!(
        "UPDATE users SET access_token = $1, refresh_token = $2 WHERE access_token = $3",
        new_access_token,
        new_refresh_token,
        access_token
    )
    .execute(conn)
    .await?;

    Ok(AccessTokens {
        access_token: new_access_token.to_string(),
        refresh_token: new_refresh_token.to_string(),
    })
}

pub struct UserId {
    id: i32,
}

pub async fn get_user_id(conn: &Pool<Postgres>, access_token: &str) -> Result<UserId, Error> {
    let user = sqlx::query_as!(
        UserId,
        "SELECT id FROM users WHERE access_token = $1",
        access_token
    )
    .fetch_one(conn)
    .await?;

    Ok(user)
}

#[derive(Serialize)]
pub struct DndCampaign {
    id: i32,
    user_id: i32,
    name: String,
    image_link: Option<String>,
    created_at: Option<chrono::NaiveDateTime>,
    last_updated: Option<chrono::NaiveDateTime>,
}

#[derive(Serialize)]
pub struct DndSession {
    id: i32,
    user_id: i32,
    campaign_id: i32,
    name: String,
    created_at: Option<chrono::NaiveDateTime>,
    last_updated: Option<chrono::NaiveDateTime>,
}

pub async fn create_dnd_campaign(
    conn: &Pool<Postgres>,
    access_token: &str,
    name: &str,
) -> Result<DndCampaign, Error> {
    let user_id = get_user_id(conn, access_token).await?;

    let res = sqlx::query_as!(
        DndCampaign,
        "INSERT INTO campaign (user_id, name) VALUES ($1, $2) RETURNING *",
        user_id.id,
        name
    )
    .fetch_one(conn)
    .await?;

    let invite_code: String = rand::thread_rng()
        .sample_iter(&Alphanumeric)
        .take(16)
        .map(char::from)
        .collect();

    sqlx::query!(
        "INSERT INTO campaign_invites (campaign_id, invite) VALUES ($1, $2)",
        res.id,
        invite_code
    )
    .execute(conn)
    .await?;

    sqlx::query!(
        "INSERT INTO campaign_players (campaign_id, player_id, role) VALUES ($1, $2, $3)",
        res.id,
        user_id.id,
        "dm"
    )
    .execute(conn)
    .await?;

    Ok(res)
}

struct DndCampaignInvite {
    campaign_id: i32,
    invite: String,
    created_at: Option<chrono::NaiveDateTime>,
    uses: i32,
}

// This needs to check for if the user is already in the campaign before adding them
// (see if it's possible to combine that into one of the existing queries)
pub async fn join_dnd_campaign(
    conn: &Pool<Postgres>,
    access_token: &str,
    invite_code: &str,
) -> Result<bool, String> {
    let user_id = get_user_id(conn, access_token)
        .await
        .map_err(|e| e.to_string())?;

    let campaign_invite = sqlx::query_as!(
        DndCampaignInvite,
        "SELECT * FROM campaign_invites WHERE invite = $1",
        invite_code
    )
    .fetch_one(conn)
    .await
    .map_err(|e| e.to_string())?;

    if campaign_invite.uses == 0 {
        return Err("Invite has no more uses".to_string());
    }

    sqlx::query!(
        "UPDATE campaign_invites SET uses = $1 WHERE invite = $2",
        campaign_invite.uses - 1,
        invite_code
    )
    .execute(conn)
    .await
    .map_err(|e| e.to_string())?;

    sqlx::query!(
        "INSERT INTO campaign_players (campaign_id, player_id) VALUES ($1, $2)",
        campaign_invite.campaign_id,
        user_id.id
    )
    .execute(conn)
    .await
    .map_err(|e| e.to_string())?;

    Ok(true)
}

pub async fn get_dnd_campaigns(
    conn: &Pool<Postgres>,
    access_token: &str,
) -> Result<Vec<DndCampaign>, Error> {
    let user_id = get_user_id(conn, access_token).await?;

    let res = sqlx::query_as!(DndCampaign, "SELECT * FROM campaign WHERE id IN (SELECT campaign_id FROM campaign_players WHERE player_id = $1)", user_id.id).fetch_all(conn).await?;

    Ok(res)
}

pub async fn create_dnd_session(
    conn: &Pool<Postgres>,
    access_token: &str,
    campaign_id: i32,
    name: &str,
) -> Result<DndSession, Error> {
    let user_id = get_user_id(conn, access_token).await?;

    let res = sqlx::query_as!(
        DndSession,
        "INSERT INTO dnd_session (user_id, campaign_id, name) VALUES ($1, $2, $3) RETURNING *",
        user_id.id,
        campaign_id,
        name
    )
    .fetch_one(conn)
    .await?;

    Ok(res)
}

pub async fn get_dnd_sessions(
    conn: &Pool<Postgres>,
    access_token: &str,
    campaign_id: i32,
) -> Result<Vec<DndSession>, Error> {
    let user_id = get_user_id(conn, access_token).await?;
    let res = sqlx::query_as!(
        DndSession,
        "SELECT * FROM dnd_session WHERE campaign_id = $1 AND campaign_id IN (SELECT campaign_id FROM campaign_players WHERE player_id = $2)",
        campaign_id,
        user_id.id
    )
    .fetch_all(conn)
    .await?;

    Ok(res)
}
